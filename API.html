<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Emerald Frame API</title>
<style type="text/css">
body {
  margin: 0;
}

h1, h2, h3, h4, h5 {
  text-indent: -4.0em;
  padding-left: 4.75em;
}

h1 {
  background-color: #fcc;
  border-top: solid red 4px;
  border-bottom: solid red 4px;
  margin-top: 1.5em;
}

h2, h3 {
  background-color: #ccf;
  border-top: solid blue 2px;
  border-bottom: solid blue 2px;
}

h4 {
  background-color: #cfc;
  padding-top: 0.5em;
  padding-bottom: 0.5em;
}

p {
  margin-left: 1.0em;
  padding-right: 2.0em;
  text-indent: 1.5em;
  line-height: 150%;
}

ul {
  list-style: none;
  padding-left: 0.5em;
}

ul ul {
  padding-left: 1.5em;
}

ul.contents a {
  text-decoration: none;
}

.code, h4 {
  font-family: 'Courier New';
}

div.code {
  border: double black 4px;
  background-color: #afa;
  color: #080;
  font-weight: bold;
  padding: 0.75em;
  margin-left: 2em;
  max-width: 60em;
  white-space: pre;
  overflow: auto;
}

div.title {
  font-size: 200%;
  text-align: center;
  margin: 25px;
}
</style>
</head>
<body>

<div class="title"><img src="logo.png" /><br />Emerald Frame API</div>

<h1>Contents</h1>
<ul class="contents">
<li><a href="#S_introduction"><b>1.</b> Introduction</a></li>
<li><a href="#S_introduction_downloads"><b>1.1</b> Downloads</a></li>
<li><a href="#S_sample"><b>2.</b> Sample Programs</a> <ul>
<li><a href="#S_sample_skeleton"><b>2.1.</b> The Skeleton</a></li>
<li><a href="#S_sample_time"><b>2.2.</b> Timed Drawing</a></li>
<li><a href="#S_sample_textures"><b>2.3.</b> Loading Textures</a></li>
</ul></li>
<li><a href="#S_reference"><b>3.</b> Reference</a> <ul>
<li><a href="#S_reference_general"><b>3.1.</b> General</a> <ul>
<li><a href="#ef_init"><span class="code">ef_init</span></a></li>
<li><a href="#ef_main"><span class="code">ef_main</span></a></li>
<li><a href="#ef_version_string"><span class="code">ef_version_string</span></a></li>
<li><a href="#ef_error_string"><span class="code">ef_error_string</span></a></li>
</ul></li>
<li><a href="#S_reference_video"><b>3.2.</b> Video</a> <ul>
<li><a href="#S_reference_video_displays"><b>3.2.1.</b> Displays</a><ul>
<li><a href="#ef_video_current_display"><span class="code">ef_video_current_display</span></a></li>
<li><a href="#ef_video_next_display"><span class="code">ef_video_next_display</span></a></li>
<li><a href="#ef_display_depth"><span class="code">ef_display_depth</span></a></li>
<li><a href="#ef_display_width"><span class="code">ef_display_width</span></a></li>
<li><a href="#ef_display_height"><span class="code">ef_display_height</span></a></li>
</ul></li>
<li><a href="#S_reference_video_drawables"><b>3.2.2.</b> Drawables</a><ul>
<li><a href="#ef_video_new_drawable"><span class="code">ef_video_new_drawable</span></a></li>
<li><a href="#ef_drawable_set_title"><span class="code">ef_drawable_set_title</span></a></li>
<li><a href="#ef_drawable_set_draw_callback"><span class="code">ef_drawable_set_draw_callback</span></a></li>
<li><a href="#ef_drawable_redraw"><span class="code">ef_drawable_redraw</span></a></li>
<li><a href="#ef_drawable_make_current"><span class="code">ef_drawable_make_current</span></a></li>
<li><a href="#ef_drawable_swap_buffers"><span class="code">ef_drawable_swap_buffers</span></a></li>
</ul></li>
<li><a href="#S_reference_video_settings"><b>3.2.3.</b> Settings</a><ul>
<li><a href="#ef_video_set_double_buffer"><span class="code">ef_video_set_double_buffer</span></a></li>
<li><a href="#ef_video_set_stereo"><span class="code">ef_video_set_stereo</span></a></li>
<li><a href="#ef_video_set_aux_buffers"><span class="code">ef_video_set_aux_buffers</span></a></li>
<li><a href="#ef_video_set_color_size"><span class="code">ef_video_set_color_size</span></a></li>
<li><a href="#ef_video_set_alpha_size"><span class="code">ef_video_set_alpha_size</span></a></li>
<li><a href="#ef_video_set_depth_size"><span class="code">ef_video_set_depth_size</span></a></li>
<li><a href="#ef_video_set_stencil_size"><span class="code">ef_video_set_stencil_size</span></a></li>
<li><a href="#ef_video_set_accumulation_size"><span class="code">ef_video_set_accumulation_size</span></a></li>
<li><a href="#ef_video_set_samples"><span class="code">ef_video_set_samples</span></a></li>
<li><a href="#ef_video_set_aux_depth_stencil"><span class="code">ef_video_set_aux_depth_stencil</span></a></li>
<li><a href="#ef_video_set_color_float"><span class="code">ef_video_set_color_float</span></a></li>
<li><a href="#ef_video_set_multisample"><span class="code">ef_video_set_multisample</span></a></li>
<li><a href="#ef_video_set_supersample"><span class="code">ef_video_set_supersample</span></a></li>
<li><a href="#ef_video_set_sample_alpha"><span class="code">ef_video_set_sample_alpha</span></a></li>
</ul></li>
<li><a href="#S_reference_video_images"><b>3.2.4.</b> Image Files</a><ul>
<li><a href="#ef_video_load_texture_file"><span class="code">ef_video_load_texture_file</span></a></li>
<li><a href="#ef_video_load_texture_memory"><span class="code">ef_video_load_texture_memory</span></a></li>
</ul></li>
</ul></li>
<li><a href="#S_reference_audio"><b>3.3.</b> Audio</a> <ul>
</ul></li>
<li><a href="#S_reference_time"><b>3.4.</b> Time</a> <ul>
<li><a href="#ef_time_new_oneshot_timer"><span class="code">ef_time_new_oneshot_timer</span></a></li>
<li><a href="#ef_time_new_repeating_timer"><span class="code">ef_time_new_repeating_timer</span></a></li>
<li><a href="#ef_timer_cancel"><span class="code">ef_timer_cancel</span></a></li>
<li><a href="#ef_time_unix_epoch"><span class="code">ef_time_unix_epoch</span></a></li>
</ul></li>
<li><a href="#S_reference_input"><b>3.5.</b> Input</a> <ul>
</ul></li>
<li><a href="#S_reference_text"><b>3.6.</b> Text</a> <ul>
</ul></li>
<li><a href="#S_reference_configuration"><b>3.7.</b> Configuration</a> <ul>
<li><a href="#ef_configuration_resource_directory"><span class="code">ef_configuration_resource_directory</span></a></li>
</ul></li>
<li><a href="#S_reference_pasteboard"><b>3.8.</b> Pasteboard</a> <ul>
</ul></li>
</ul></li>
</ul>

<a name="S_introduction"><h1>1. Introduction</h1></a>

<p>Emerald Frame is a thin platform-abstraction layer which wraps setup code for OpenGL,
OpenAL, and several other libraries; it is oriented towards game development.  More
specifically, Emerald Frame provides functionality that most game programmers want, but
that they would otherwise have to obtain from platform-specific libraries.  It is
similar in philosophy to SDL and glfw, but different (and, I believe, improved) from
those.</p>

<p>Compared to SDL, Emerald Frame's most noticeable difference is its omission:  Nothing
relating to raw framebuffer access.  In this modern world, framebuffer access is no
longer the efficiency gain it once was; the new way to program is with OpenGL.  So,
Emerald Frame focuses on getting your OpenGL code set up and running with the minimal
amount of fuss.</p>

<p>Another difference from SDL that I'd like to call your attention to is the event
processing model.  With SDL, your code implements the event loop.  With Emerald Frame,
the library implements the event loop, invoking callbacks which you have installed as
appropriate.</p>

<p>Emerald Frame is also larger in scope than SDL, with such features as image processing
(including the ability to convert an image file directly into an OpenGL texture), text
processing (including multi-line layout), USB game-controllers, saved preferences,
and operating system pasteboard access.</p>

<p>Emerald Frame is designed to be easy to bind against from programming languages other
than C; for example, it does not rely on preprocessor macros, structure layout, or
statically-allocated variables, all of which are frequent sticking points in
foreign-function interfaces.</p>

<p>Emerald Frame, lastly, is designed to stay out of your way.  You should be able to
get in, do what you need to do, and get out, with minimal fuss.</p>


<a name="S_introduction_downloads"><h2>1.1. Downloads</h2></a>


<a name="S_sample"><h1>2. Sample Programs</h1></a>
<a name="S_sample_skeleton"><h2>2.1 The Skeleton</h2></a>

<p>I know this is the only documentation a lot of you will read, so without further
preamble:</p>

<div class="code">#include "emerald-frame.h"


void init_gl(EF_Drawable drawable);
void draw(EF_Drawable drawable, void *context);


int main(int argc, char **argv) {
    ef_init((utf8 *) "Test Application");
    
    ef_video_set_double_buffer(True);
    ef_video_set_color_size(24);
    ef_video_set_alpha_size(8);
    ef_video_set_depth_size(8);
    ef_video_set_stencil_size(8);
    ef_video_set_accumulation_size(24);
    ef_video_set_samples(5);
    ef_video_set_multisample(True);
    EF_Drawable drawable = ef_video_new_drawable(640, 480, False, NULL);
    ef_drawable_set_draw_callback(drawable, draw, NULL);
    
    init_gl(drawable);
    
    ef_main();
}


void init_gl(EF_Drawable drawable) {
    ef_drawable_make_current(drawable);
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, 640, 0, 480, -300, 300);
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}


void draw(EF_Drawable drawable, void *context) {
    glClearColor(0.0f, 0.0f, 0.5f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    ef_drawable_swap_buffers(drawable);
}
</div>

<p>Even with this short sample, there are some key things to notice.</p>

<p>First, it <b>is not necessary to #include &lt;GL.h&gt;</b>.  This is because
the include name of that file differs from system to system; to make your programs
more portable, Emerald Frame finds it for you.  The same goes for all the other libraries
Emerald Frame wraps around.  This has a drawback - namespace pollution - but the
portability gain justifies it.</p>

<p>Second, <b>buffer options are set before creating the drawable</b>.  It has to be
this way, because these options are used to determine what kind of drawable to create.
All those calls like <span class="code">ef_video_set_double_buffer(True)</span> must
come before the call to <span class="code">ef_video_new_drawable(...)</span>.</p>

<p>Third, <b>buffer options default to a minimal set</b>.  There's no way for Emerald
Frame to know what options you consider standard and normal.  Double-buffering has to
be explicitly turned on if you want it (you might not).  Bit depth has to be explicitly
set to 24 bits per pixel.  If you leave out the calls to set the sizes of the depth
buffer, stencil buffer, and accumulation buffer, those buffers will be left out.</p>

<p>Lastly, <b>call <span class="code">ef_drawable_swap_buffers(...)</span> or
<span class="code">glFlush()</span></b> at the end of each
frame.  This has to be explicit, because there is no a priori way of knowing that you
actually want to draw changes to the screen at all!  If you wanted to leave the screen
the same, you would leave this call out.  It should be
 <span class="code">ef_drawable_swap_buffers</span> if your window is double-buffered,
or <span class="code">glFlush</span> if it is not.  Because these have different
(but overlapping) behaviors, there is no way for Emerald Frame to know which you
intended.</p>

<p>Each example will serve as the basis for the later examples, adding on to the ones
that have come before.  For your convenience, you can get the full working versions of
the examples in <a href="#S_introduction_downloads">the downloads section</a>, but I
recommend you actually read the chapters so that you will understand how they work.</p>


<a name="S_sample_time"><h2>2.2. Timed Drawing</h2></a>

<p>The program isn't very interesting with no motion.  We will add a timer that fires
50 times a second, redrawing the screen each time.  We'll use this to animate a spinning
triangle.</p>

<p>Our program will have a new function, <span class="code">frame</span>, which is
registered as a timer callback and invoked every frame.  Add the following to the
function declarations at the top of the file:</p>

<div class="code">void frame(EF_Timer timer, void *context);</div>

<p>In order to ensure smooth animation, the program won't just rely on the assumption
that exactly one frame has passed since the last time it drew - it will actually keep
a counter and check how much time has elapsed.  To do this it requires a "zero time".
Add the following to a new section right after the function declarations at the
top of the file, and before the definition of <span class="code">main</span>:</p>

<div class="code">static uint64_t startup_time;</div>

<p>We need to initialize the "zero time" when the program starts up.  We also need to
create the timer that will call <span class="code">frame</span>.  Add the following
between the call to <span class="code">init_gl</span> and the call to
<span class="code">ef_main</span>:</p>

<div class="code">    startup_time = ef_time_unix_epoch();

    ef_time_new_repeating_timer(20, frame, (void *) drawable);
</div>

<p>We want 50 fps, so we specify that the timer should fire every 20 milliseconds;
1000 / 50 = 20.</p>

<p>The function <span class="code">frame</span> needs a definition.  It does very little
work, just triggering a redraw, and offloading all the actual work to
<span class="code">draw</span>.  In a complicated program, you would likely put the
simulation code in <span class="code">frame</span> to ensure that it runs no more often
than it's supposed to - the draw callback can be invoked for other reasons as well.
Add the following function definition at the end of the file:</p>

<div class="code">void frame(EF_Timer timer, void *context) {
    EF_Drawable drawable = (EF_Drawable) context;
    ef_drawable_redraw(drawable);
}
</div>

<p>Notice how we used the <span class="code">context</span> parameter.  This is an
opaque value as far as Emerald Frame is concerned - it can hold anything you find
useful.  The callback needs to know what drawable to update, so we use the drawable as
our context parameter.  We pass it in to
<span class="code">ef_time_new_repeating_timer</span>, and each invocation of
<span class="code">frame</span> receives it.  We have to do some typecasting because,
for versatility, the context parameter is a void pointer.</p>

<p>Finally, we need to actually draw our triangle.  Replace the definition of the
<span class="code">draw</span> function with the following:</p>

<div class="code">void draw(EF_Drawable drawable, void *context) {
    uint64_t current_time = ef_time_unix_epoch();
    uint64_t elapsed_frames = (current_time - startup_time) / 20;
    
    glClearColor(0.0f, 0.0f, 0.5f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glPushMatrix();

    glTranslatef(320.0f, 240.0f, 0.0f);
    glRotatef(elapsed_frames * (90.0f / 100.0f), 0.0f, 0.0f, 1.0f);

    glColor4f(1.0f, 1.0f, 0.0f, 1.0f);
    glBegin(GL_TRIANGLES);
    glVertex2s(0, 120);
    glVertex2s(60, -60);
    glVertex2s(-60, -60);
    glEnd();
    
    glPopMatrix();

    ef_drawable_swap_buffers(drawable);
}
</div>

<p>The first two lines check the elapsed time since "zero" to determine what frame
we're at, and therefore what state the animation is in.  The call to
<span class="code">glRotatef</span> is what actually produces the animation, feeding
the elapsed number of frames into the parameter that determines what angle to rotate
by.  This code is set to rotate 90 degrees in 100 frames, which, since we are running
at 50 fps, is a full circle every eight seconds.  Like clockwork!</p>


<a name="S_sample_textures"><h2>2.3. Loading Textures</h2></a>

<p>Although it is certainly possible to have a program which uses only vector graphics,
it's often desirable to include bitmapped images.  In OpenGL, this is accomplished using
textures; but the problem you may be having is converting a file on disk into a
texture in video memory.  Emerald Frame has a facility to do this for you.</p>

<p>Start from the completed example from <a href="#S_sample_time">section two</a>.</p>

<p>We're going to be using some memory-management functions, so add the following at
the end of the includes section:</p>

<div class="code">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</div>

<p>We're going to create a new function that loads the textures, so add the following at
the start of the function prototypes:</p>

<div class="code">void load_textures(EF_Drawable drawable);
</div>

<p>In OpenGL, to access a texture you need to know its texture ID.  For simplicity, we
will keep texture IDs in a global array; add the following at the end of the global
variables:</p>

<div class="code">static GLuint texture_ids[3];
</div>

<p>Since textures are loaded into OpenGL contexts, and the context isn't created until
the drawable is, we have to put the call to <span class="code">load_textures</span>
after the call to <span class="code">ef_drawable_set_drawable_callback</span>.
Place the following immediately above the call to
<span class="code">init_gl</span> inside <span class="code">main</span>:</p>

<div class="code">    load_textures(drawable);
</div>

<p>As mentioned above, we need to enable the texture feature before we can use it.  Add
the following to the end of <span class="code">init_gl</span>:</p>

<div class="code">    glEnable(GL_TEXTURE_2D);
</div>

<p>Add the following function definition immediately after the end of
<span class="code">main</span>:</p>

<div class="code">void load_textures(EF_Drawable drawable) {
    ef_drawable_make_current(drawable);
    
    glEnable(GL_TEXTURE_2D);
    
    glGenTextures(3, texture_ids);
    
    utf8 *resource_path = ef_configuration_resource_directory();
    
    utf8 *test_texture_path;
    
    test_texture_path = malloc((strlen((char *) resource_path) + 128) * sizeof(utf8));
    strcpy((char *) test_texture_path, (char *) resource_path);
    strcat((char *) test_texture_path, "test-color.png");
    ef_video_load_texture_file(test_texture_path, texture_ids[0], True);
    free(test_texture_path);
    
    test_texture_path = malloc((strlen((char *) resource_path) + 128) * sizeof(utf8));
    strcpy((char *) test_texture_path, (char *) resource_path);
    strcat((char *) test_texture_path, "test-transparent.png");
    ef_video_load_texture_file(test_texture_path, texture_ids[1], True);
    free(test_texture_path);
    
    test_texture_path = malloc((strlen((char *) resource_path) + 128) * sizeof(utf8));
    strcpy((char *) test_texture_path, (char *) resource_path);
    strcat((char *) test_texture_path, "test-partial-alpha.png");
    ef_video_load_texture_file(test_texture_path, texture_ids[2], True);
    free(test_texture_path);
}
</div>

<p>Before we can work with textures, we have to turn on the texture facility; we do this
with the call to <span class="code">glEnable(GL_TEXTURE_2D)</span>.</p>

<p>In order to load textures, we need to allocate IDs for them; the call to
<span class="code">glGenTextures</span> does that, generating three IDs that we can
use in later calls.  These IDs will remain allocated even if you unload the textures
themselves, unless you explicitly deallocate them.  Since
<span class="code">glGenTextures</span> and <span class="code">glEnable</span> need
there to be a current OpenGL context, we have to call
<span class="code">ef_drawable_make_current</span> first, so we do that, too.</p>

<p>We can't perform the actual loading quite yet; we have another problem - how do we
find the files which we are distributing with the application?  It can be nontrivial to
install things such that you can find them later.  Emerald Frame recommends that you
follow the most common practices for your platform:  On Windows, place them in the same
directory as the executable.  On the Mac, place them in the Resources directory inside
the application bundle (XCode will do this for you if you add them to the project).
In either case, the same Emerald Frame library function will tell you the appropriate
path to find them at:
<a href="ef_configuration_resource_directory">ef_configuration_resource_directory</a>.</p>

<p>Now we have some relatively boring string-manipulation code.  If you're used to a
language with advanced string processing, this may look arcane to you, but it's the C
way to concatenate two strings.  The meat of these three stanzas is the call in each
one to <span class="code">ef_video_load_texture_file</span>; this library call fetches
the image from the filename it's given, and loads it into the texture with the ID it's
also given.  The <span class="code">True</span> parameter instructs it to generate
mipmaps automatically, so that the image will be scaled smoothly up and down if it's
drawn at different sizes.</p>

<p>So much for loading the textures; let's move on to drawing them.  I've provided
three sample images; the first is opaque, the second has a transparent background, and
the third illustrates partial transparency with blending.  For the blending to work,
we need to turn it on first, so add the following to the end of
<span class="code">init_gl</span>:</p>

<div class="code">    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
</div>

<p>It's not my purpose in this tutorial to teach OpenGL, so I'm simply going to
present the <span class="code">draw</span> function in its entirety.  If you know
OpenGL, it should be clear how it works.  Replace the definition of the
<span class="code">draw</span> function with the following:</p>

<div class="code">void draw(EF_Drawable drawable, void *context) {
    uint64_t current_time = ef_time_unix_epoch();
    uint64_t elapsed_frames = (current_time - startup_time) / 20;
    
    glClearColor(0.0f, 0.0f, 0.5f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glBindTexture(GL_TEXTURE_2D, 0);
    glDisable(GL_BLEND);
    
    glPushMatrix();
    
    glTranslatef(320.0f, 240.0f, 0.0f);
    glRotatef(elapsed_frames * (90.0f / 100.0f), 0.0f, 0.0f, 1.0f);

    glColor4f(1.0f, 1.0f, 0.0f, 1.0f);
    glBegin(GL_TRIANGLES);
    glVertex2s(0, 120);
    glVertex2s(60, -60);
    glVertex2s(-60, -60);
    glEnd();

    glPopMatrix();
    
    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
    glEnable(GL_BLEND);
    
    glBindTexture(GL_TEXTURE_2D, texture_ids[0]);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f);
    glVertex2s(0, 0);
    glTexCoord2f(1.0f, 1.0f);
    glVertex2s(128, 0);
    glTexCoord2f(1.0f, 0.0f);
    glVertex2s(128, 128);
    glTexCoord2f(0.0f, 0.0f);
    glVertex2s(0, 128);
    glEnd();
    
    glBindTexture(GL_TEXTURE_2D, texture_ids[1]);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f);
    glVertex2s(128, 0);
    glTexCoord2f(1.0f, 1.0f);
    glVertex2s(256, 0);
    glTexCoord2f(1.0f, 0.0f);
    glVertex2s(256, 128);
    glTexCoord2f(0.0f, 0.0f);
    glVertex2s(128, 128);
    glEnd();

    glBindTexture(GL_TEXTURE_2D, texture_ids[2]);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, 1.0f);
    glVertex2s(256, 0);
    glTexCoord2f(1.0f, 1.0f);
    glVertex2s(384, 0);
    glTexCoord2f(1.0f, 0.0f);
    glVertex2s(384, 128);
    glTexCoord2f(0.0f, 0.0f);
    glVertex2s(256, 128);
    glEnd();
        
    ef_drawable_swap_buffers(drawable);
}
</div>

<p>There is one subtlety I would like to call your attention to:  The two coordinate
systems.  Emerald Frame loads images such that the top-left corner is at (0.0, 0.0) in
texture space.  However, we set up a coordinate system for the window which - per the
usual convention for OpenGL, though it's by no means universal - has (0, 0) at the
lower-left corner.  This means that images need to be flipped vertically in order to
appear properly.  We accomplish this by matching texture coordinates (0.0, 0.0) to
the bottom-left of the square we're drawing, (0.0, 1.0) to the top-left, and so on.</p>

<p>Now we have three images displaying, along with the rotating triangle.  Nice, huh?</p>


<a name="S_reference"><h1>3. Reference</h1></a>

<a name="S_reference_general"><h2>3.1. General</h2></a>

<a name="ef_init"><h4>EF_Error ef_init(utf8 *application_name)</h4></a>

<p>Must be called before any other Emerald Frame function.  Initializes all the libraries
which go with Emerald Frame.</p>

<a name="ef_main"><h4>void ef_main()</h4></a>

<p>Begins processing the event loop.  Does not return until program exit.</p>

<a name="ef_version_string"><h4>utf8 *ef_version_string()</h4></a>

<p>Returns a human-readable string describing the version number of Emerald Frame.
Should not be used to test for the existence of specific capabilities; when such testing
becomes necessary in a future version, a gestalt-like query interface will be
implemented.</p>

<a name="ef_error_string"><h4>utf8 *ef_error_string(EF_Error error)</h4></a>

<p>Returns a human-readable string describing the error condition
<span class="code">error</span>, which should be a code returned by another Emerald
Frame library function.  Not useful, for example, for OpenGL error codes.</p>

<a name="S_reference_video"><h2>3.2. Video</h2></a>

<a name="S_reference_video_displays"><h3>3.2.1. Displays</h3></a>

<p><b>Displays</b> are physical screens attached to the computer.  It is useful to
work with them whenever the user has multiple screens, whether to identify them all and
open each one in turn in full-screen mode, or to choose which one to open a window
on.</p>

<a name="ef_video_current_display"><h4>EF_Display ef_video_current_display()</h4></a>

<p>Returns the display which the user is most likely to be currently interacting with,
as determined by the operating system.  Different OSes have different preferred
behavior for this, so it's best to respect their choices.</p>

<a name="ef_video_next_display"><h4>EF_Display ef_video_next_display()</h4></a>

<p>Used to iterate through all displays in some order.  No specific order is
guaranteed; in particular, use
<a href="ef_video_current_display">ef_video_current_display()</a>
if you wish to find the "main" display.  Pass <span class="code">NULL</span> to
retrieve the first in the list, then on each subsequent call, pass the display you
received last time to retrieve the one following it.</p>

<a name="ef_display_depth"><h4>int ef_display_depth(EF_Display display)</h4></a>

<p>Returns the number of bits per pixel used by the given display.  This is often 24.</p>

<a name="ef_display_width"><h4>int ef_display_width(EF_Display display)</h4></a>

<p>Returns the width in pixels of the given display.</p>

<a name="ef_display_height"><h4>int ef_display_height(EF_Display display)</h4></a>

<p>Returns the height in pixels of the given display.</p>

</ul>

<a name="S_reference_video_drawables"><h3>3.2.2. Drawables</h3></a>

<p>A <b>drawable</b> is a context into which you can perform graphics commands.  It is
either a window, or the entire contents of a display.

<a name="ef_video_new_drawable"><h4>EF_Drawable ef_video_new_drawable(<br />int width,<br />int height,<br />boolean full_screen,<br />EF_Display display)</h4></a>

<p>Creates a new drawable of the specified size.  If
<span class="code">full_screen</span> is <span class="code">True</span>, enters
full-screen mode.  If <span class="code">display</span> is provided, the window is
positioned on the given display (or, in full-screen mode, the given display is used);
otherwise, it is as if the current display in the sense of
<a href="#ef_video_current_display">ef_video_current_display()</a>
has been passed.  The created drawable is immediately displayed to the user.</p>

<a name="ef_drawable_set_title"><h4>void ef_drawable_set_title(EF_Drawable drawable, utf8* title)</h4></a>

<p>For drawables which are windows with titlebars or which otherwise have some
user-visible title string, sets that string.</p>

<a name="ef_drawable_set_draw_callback"><h4>void ef_drawable_set_draw_callback(<br />EF_Drawable drawable,<br />void (*callback)(EF_Drawable drawable, void *context),<br />void *context)</h4></a>

<p>Sets a callback to be invoked every time the drawable is due to be redrawn.  The
function passed as the <span class="code">callback</span> parameter will be called with
two parameters: the drawable in question, and the user-supplied
<span class="code">context</span> parameter given when this function is called.</p>

<p>If there is an existing callback, the new one replaces it.  If
<span class="code">NULL</span> is passed, any existing callback is removed.</p>

<p>Note that, though it is one piece of the task, setting a callback will not by itself
cause animation to occur; for that, see
<a name="S_sample_time">2.2. Timed Drawing</a>.</p>

<a name="ef_drawable_redraw"><h4>void ef_drawable_redraw(EF_Drawable drawable)</h4></a>

<p>Causes the given drawable to redraw, triggering a draw callback, as soon as
possible.  This is useful from a timer, for example, to produce animation.</p>

<a name="ef_drawable_make_current"><h4>void ef_drawable_make_current(EF_Drawable drawable)</h4></a>

<p>Causes the OpenGL context of the given drawable to become the current one, so that
all future drawing operations will be performed upon it.  Necessary before each set of
drawing operations even if you have only a single drawable, but can be omitted inside
draw callbacks.</p>

<a name="ef_drawable_swap_buffers"><h4>void ef_drawable_swap_buffers(EF_Drawable drawable)</h4></a>

<p>Causes OpenGL to copy the back buffer of the drawable to the front buffer; typically,
this causes any changes since the last call of it to be displayed to the user.</p>

<p>This function implicitly calls <span class="code">glFlush()</span>.</p>

<a name="S_reference_video_settings"><h3>3.2.3. Settings</h3></a>

<a name="ef_video_set_double_buffer"><h4>void ef_video_set_double_buffer(boolean double_buffer)</h4></a>

<p>Sets the double-buffering attribute to the provided value; this attribute will be
used for all future drawables that are created (it does not modify existing
drawables).</p>

<a name="ef_video_set_stereo"><h4>void ef_video_set_stereo(boolean stereo)</h4></a>

<p>Sets the stereo attribute to the provided value; this attribute will be
used for all future drawables that are created (it does not modify existing
drawables).</p>

<a name="ef_video_set_aux_buffers"><h4>void ef_video_set_aux_buffers(int aux_buffers)</h4></a>

<p>Sets the number of auxilliary buffers to the provided value; this attribute will be
used for all future drawables that are created (it does not modify existing
drawables).</p>

<a name="ef_video_set_color_size"><h4>void ef_video_set_color_size(int color_size)</h4></a>

<p>Sets the number of bits for all color channels combined of each pixel to the provided
value; this attribute will be used for all future drawables that are created (it does
not modify existing drawables).  The number of bits is typically 24 for
red-green-blue-alpha, since the depth of the alpha channel is set separately.</p>

<a name="ef_video_set_alpha_size"><h4>void ef_video_set_alpha_size(int alpha_size)</h4></a>

<p>Sets the number of bits for the alpha channel of each pixel to the provided value;
this attribute will be used for all future drawables that are created (it does not
modify existing drawables).  A value of 0 means no alpha channel.</p>

<a name="ef_video_set_depth_size"><h4>void ef_video_set_depth_size(int depth_size)</h4></a>

<p>Sets the number of bits in the depth-buffer for each pixel to the provided value;
this attribute will be used for all future drawables that are created (it does not
modify existing drawables).  A value of 0 means no depth buffer.</p>

<a name="ef_video_set_stencil_size"><h4>void ef_video_set_stencil_size(int stencil_size)</h4></a>

<p>Sets the number of bits in the stencil buffer for each pixel to the provided value;
this attribute will be used for all future drawables that are created (it does not
modify existing drawables).  A value of 0 means no stencil buffer.</p>

<a name="ef_video_set_accumulation_size"><h4>void ef_video_set_accumulation_size(int accumulation_size)</h4></a>

<p>Sets the number of bits in the accumulation buffer for each pixel to the provided
value; this attribute will be used for all future drawables that are created (it does
not modify existing drawables).  A value of 0 means no accumulation buffer.</p>

<a name="ef_video_set_samples"><h4>void ef_video_set_samples(int samples)</h4></a>

<p>Sets the number of samples per pixel when using multisampling or supersampling
to the provided value; this attribute will be used for all future drawables that are
created (it does not modify existing drawables).</p>

<a name="ef_video_set_aux_depth_stencil"><h4>void ef_video_set_aux_depth_stencil(boolean aux_depth_stencil)</h4></a>

<p>Sets whether each auxilliary buffer has its own depth and stencil buffers; this
attribute will be used for all future drawables that are created (it does not modify
existing drawables).</p>

<a name="ef_video_set_color_float"><h4>void ef_video_set_color_float(boolean color_float)</h4></a>

<p>Sets whether colors are represented as floats; this attribute will be
used for all future drawables that are created (it does not modify existing
drawables).</p>

<a name="ef_video_set_multisample"><h4>void ef_video_set_multisample(boolean multisample)</h4></a>

<p>Sets whether to use multisampling; this attribute will be used for all future
drawables that are created (it does not modify existing drawables).  For there to be
any effect, it is also necessary to set the number of samples per pixel to some number
greater than one, using <a href="#ef_video_set_samples">ef_video_set_samples(...)</a>.
This is a very popular method of doing full-screen antialiasing.</p>

<a name="ef_video_set_supersample"><h4>void ef_video_set_supersample(boolean supersample)</h4></a>

<p>Sets whether to use supersampling; this attribute will be used for all future
drawables that are created (it does not modify existing drawables).  For there to be
any effect, it is also necessary to set the number of samples per pixel to some number
greater than one, using <a href="#ef_video_set_samples">ef_video_set_samples(...)</a>.
This is a somewhat unpopular method of doing full-screen antialiasing.</p>

<a name="ef_video_set_sample_alpha"><h4>void ef_video_set_sample_alpha(boolean sample_alpha)</h4></a>

<p>Sets whether multisampling, if enabled, affects the alpha channel; this attribute
will be used for all future drawables that are created (it does not modify existing
drawables).</p>

<a name="S_reference_video_images"><h3>3.2.4. Image Files</h3></a>

<a name="ef_video_load_texture_file"><h4>EF_Error ef_video_load_texture_file(utf8 *filename, GLuint id, boolean build_mipmaps)</h4></a>

<p>Loads a bitmap image from an external file into an OpenGL texture.  The application
must have already allocated the texture ID, as with
<span class="code">glGenTextures</span>.
If the image data is not a square image with a power-of-two size, the created texture is
the next larger such size that completely contains the image.
What file formats are supported depends upon operating-system support, but will include
PNG, GIF, and JPEG.
Returns <span class="code">EF_ERROR_FILE</span> if the file cannot be found or cannot be
read.  Returns <span class="code">EF_ERROR_IMAGE_DATA</span> if the file cannot be
interpreted as a valid image with a supported pixel format.</p>

<!--
(It actually isn't, but this text is here in case things change.)
<p>The image's alpha channel, if present, is premultiplied with the color channels; this
means that it should be composited with
<span class="code">glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)</span>,
<b>not</b> with
<span class="code">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</span>.</p>
-->

<a name="ef_video_load_texture_memory"><h4>EF_Error ef_video_load_texture_memory(uint8_t *data, size_t size, GLuint id, boolean build_mipmaps)</h4></a>

<p>As <a href="#ef_video_load_texture_file">ef_video_load_texture_file</a>, but for
the case where the data is already in memory (perhaps it came from a database or from
an application-specific wrapper file).  Returns
<span class="code">EF_ERROR_IMAGE_DATA</span>
if the data cannot be interpreted as a valid image with a supported pixel format.</p>

<a name="S_reference_audio"><h2>3.3. Audio</h2></a>

<a name="S_reference_time"><h2>3.4. Time</h2></a>

<a name="ef_time_new_oneshot_timer"><h4>EF_Timer ef_time_new_oneshot_timer(<br />int milliseconds,<br />void (*callback)(EF_Timer timer, void *context),<br />void *context)</h4></a>

<p>Creates a new timer which will fire <span class="code">milliseconds</span>
milliseconds after the current time, calling the given callback with itself and the
given context function.  The timer will fire once and then expire.  After firing, the
timer is automatically disposed of.</p>

<a name="ef_time_new_repeating_timer"><h4>ef_time_new_repeating_timer(<br />int milliseconds,<br />void (*callback)(EF_Timer timer, void *context),<br />void *context)</h4></a>

<p>Creates a new timer which will fire <span class="code">milliseconds</span>
milliseconds after the current time, calling the given callback with itself and the
given context function.  The timer will fire repeatedly, every time the same time
interval has passed again..</p>

<a name="ef_timer_cancel"><h4>void ef_timer_cancel(EF_Timer timer)</h4></a>

<p>Cancels a oneshot timer which has not yet fired, or a repeating timer.  After being
cancelled, the timer is automatically disposed of and will not fire.</p>

<a name="ef_time_unix_epoch"><h4>uint64_t ef_time_unix_epoch()</h4></a>

<p>Returns the current time, expressed as milliseconds since January 1st, 1970 - the
"unix epoch".</p>

<a name="S_reference_input"><h2>3.5. Input</h2></a>

<a name="S_reference_text"><h2>3.6. Text</h2></a>

<a name="S_reference_configuration"><h2>3.7. Configuration</h2></a>

<a name="ef_configuration_resource_directory"><h4>utf8 *ef_configuration_resource_directory()</h4></a>

<p>Returns the path to a platform-specific directory where resource files bundled as part of the application may be found.  The path is returned with a trailing slash (or operating-system-appropriate path component separator).  The path is in memory managed by the library and is valid only until the next call to this function; therefore, this function is not thread-safe.</p>

<p>On the Mac, this is the <span class="code">Resources</span> directory inside the application bundle.</p>

<p>On Windows, this is the directory containing the executable.</p>

<a name="S_reference_pasteboard"><h2>3.8. Pasteboard</h2></a>

</body>
</html>
